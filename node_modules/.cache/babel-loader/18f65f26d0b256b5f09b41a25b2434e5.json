{"ast":null,"code":"// stepper is used a lot. Saves allocation to return the same array wrapper.\n// This is fine and danger-free against mutations because the callsite\n// immediately destructures it and gets the numbers inside without passing the\n\"use strict\";\n\nexports.__esModule = true;\nexports[\"default\"] = stepper;\nvar reusedTuple = [0, 0];\n\nfunction stepper(secondPerFrame, x, v, destX, k, b, precision) {\n  // Spring stiffness, in kg / s^2\n  // for animations, destX is really spring length (spring at rest). initial\n  // position is considered as the stretched/compressed position of a spring\n  var Fspring = -k * (x - destX); // Damping, in kg / s\n\n  var Fdamper = -b * v; // usually we put mass here, but for animation purposes, specifying mass is a\n  // bit redundant. you could simply adjust k and b accordingly\n  // let a = (Fspring + Fdamper) / mass;\n\n  var a = Fspring + Fdamper;\n  var newV = v + a * secondPerFrame;\n  var newX = x + newV * secondPerFrame;\n\n  if (Math.abs(newV) < precision && Math.abs(newX - destX) < precision) {\n    reusedTuple[0] = destX;\n    reusedTuple[1] = 0;\n    return reusedTuple;\n  }\n\n  reusedTuple[0] = newX;\n  reusedTuple[1] = newV;\n  return reusedTuple;\n}\n\nmodule.exports = exports[\"default\"]; // array reference around.","map":{"version":3,"sources":["/Users/aoliu/Documents/Project/node_modules/react-motion/lib/stepper.js"],"names":["exports","__esModule","stepper","reusedTuple","secondPerFrame","x","v","destX","k","b","precision","Fspring","Fdamper","a","newV","newX","Math","abs","module"],"mappings":"AAEA;AACA;AACA;AACA;;AAEAA,OAAO,CAACC,UAAR,GAAqB,IAArB;AACAD,OAAO,CAAC,SAAD,CAAP,GAAqBE,OAArB;AAEA,IAAIC,WAAW,GAAG,CAAC,CAAD,EAAI,CAAJ,CAAlB;;AAEA,SAASD,OAAT,CAAiBE,cAAjB,EAAiCC,CAAjC,EAAoCC,CAApC,EAAuCC,KAAvC,EAA8CC,CAA9C,EAAiDC,CAAjD,EAAoDC,SAApD,EAA+D;AAC7D;AAEA;AACA;AACA,MAAIC,OAAO,GAAG,CAACH,CAAD,IAAMH,CAAC,GAAGE,KAAV,CAAd,CAL6D,CAO7D;;AACA,MAAIK,OAAO,GAAG,CAACH,CAAD,GAAKH,CAAnB,CAR6D,CAU7D;AACA;AACA;;AACA,MAAIO,CAAC,GAAGF,OAAO,GAAGC,OAAlB;AAEA,MAAIE,IAAI,GAAGR,CAAC,GAAGO,CAAC,GAAGT,cAAnB;AACA,MAAIW,IAAI,GAAGV,CAAC,GAAGS,IAAI,GAAGV,cAAtB;;AAEA,MAAIY,IAAI,CAACC,GAAL,CAASH,IAAT,IAAiBJ,SAAjB,IAA8BM,IAAI,CAACC,GAAL,CAASF,IAAI,GAAGR,KAAhB,IAAyBG,SAA3D,EAAsE;AACpEP,IAAAA,WAAW,CAAC,CAAD,CAAX,GAAiBI,KAAjB;AACAJ,IAAAA,WAAW,CAAC,CAAD,CAAX,GAAiB,CAAjB;AACA,WAAOA,WAAP;AACD;;AAEDA,EAAAA,WAAW,CAAC,CAAD,CAAX,GAAiBY,IAAjB;AACAZ,EAAAA,WAAW,CAAC,CAAD,CAAX,GAAiBW,IAAjB;AACA,SAAOX,WAAP;AACD;;AAEDe,MAAM,CAAClB,OAAP,GAAiBA,OAAO,CAAC,SAAD,CAAxB,C,CACA","sourcesContent":["\n\n// stepper is used a lot. Saves allocation to return the same array wrapper.\n// This is fine and danger-free against mutations because the callsite\n// immediately destructures it and gets the numbers inside without passing the\n\"use strict\";\n\nexports.__esModule = true;\nexports[\"default\"] = stepper;\n\nvar reusedTuple = [0, 0];\n\nfunction stepper(secondPerFrame, x, v, destX, k, b, precision) {\n  // Spring stiffness, in kg / s^2\n\n  // for animations, destX is really spring length (spring at rest). initial\n  // position is considered as the stretched/compressed position of a spring\n  var Fspring = -k * (x - destX);\n\n  // Damping, in kg / s\n  var Fdamper = -b * v;\n\n  // usually we put mass here, but for animation purposes, specifying mass is a\n  // bit redundant. you could simply adjust k and b accordingly\n  // let a = (Fspring + Fdamper) / mass;\n  var a = Fspring + Fdamper;\n\n  var newV = v + a * secondPerFrame;\n  var newX = x + newV * secondPerFrame;\n\n  if (Math.abs(newV) < precision && Math.abs(newX - destX) < precision) {\n    reusedTuple[0] = destX;\n    reusedTuple[1] = 0;\n    return reusedTuple;\n  }\n\n  reusedTuple[0] = newX;\n  reusedTuple[1] = newV;\n  return reusedTuple;\n}\n\nmodule.exports = exports[\"default\"];\n// array reference around."]},"metadata":{},"sourceType":"script"}